# Implementation Plan: DVI Character Display GPU

**Branch**: `003-hdmi-character-display` | **Date**: 2025-12-27 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/003-hdmi-character-display/spec.md`

## Summary

This feature implements a character-based display controller (GPU) for the RetroCPU system, generating DVI video signals (640x480 @ 60Hz) over the HDMI physical connector. The GPU provides memory-mapped registers for writing ASCII characters, controlling cursor position, switching between 40-column and 80-column text modes, and configuring 8-color (3-bit RGB) foreground/background colors. The design prioritizes hardware validation and proof-of-concept using the reference implementation from https://github.com/splinedrive/my_hdmi_device before building the full character display system.

## Technical Context

**HDL Language**: Verilog (SystemVerilog for testbenches if needed)
**Target Architecture**: 6502-compatible retro computer system with DVI video output
**Testing Framework**: cocotb (Python-based HDL verification)
**Simulation**: Icarus Verilog (iverilog) primary, Verilator secondary
**Synthesis**: Yosys + nextpnr-ecp5 for Colorlight i5 FPGA
**Target FPGA**: Colorlight i5 (Lattice ECP5-25F) with HDMI-capable carrier board
**Project Type**: FPGA/HDL - peripheral controller module
**Timing Goals**: 25.175 MHz pixel clock (640x480 @ 60Hz VGA timing), system bus interface at CPU clock speed (TBD during integration)
**Resource Constraints**: ECP5-25F has ~24K LUTs, ~112 Kb RAM; character buffer requires ~2KB (40x25) to ~4KB (80x25), font ROM ~1.5KB (96 chars x 16 bytes)
**Module Scope**: Display controller peripheral - DVI signal generation, character buffer, font renderer, cursor logic, memory-mapped I/O interface

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify compliance with RetroCPU Constitution (.specify/memory/constitution.md):

- [x] **Test-Driven Design**: Cocotb tests will be written for all modules (DVI timing, character buffer, font renderer, register interface)
- [x] **Simplicity Over Performance**: Design prioritizes clarity - straightforward scanline rendering, simple state machines for control logic
- [x] **Module Reusability**: Clean module boundaries - DVI signal generator, character buffer, font ROM, cursor controller can be reused/tested independently
- [x] **Educational Clarity**: Reference code study phase ensures understanding; documentation will explain VGA timing, character rendering pipeline
- [x] **Open Source Tooling**: Using iverilog, cocotb, yosys, nextpnr-ecp5 exclusively
- [x] **Quality Gates**: Plan includes hardware validation, cocotb unit tests, integration tests, synthesis verification
- [x] **Technology Stack**: Verilog, cocotb, open source ECP5 toolchain

**Constitution Check Status**: ✅ PASSED - All gates satisfied

## Project Structure

### Documentation (this feature)

```text
specs/003-hdmi-character-display/
├── plan.md              # This file
├── research.md          # Phase 0: Hardware validation, reference code study, DVI timing research
├── data-model.md        # Phase 1: Register map, character buffer layout, state machines
├── quickstart.md        # Phase 1: Build and test instructions
├── contracts/           # Phase 1: Register interface specifications
│   └── register_map.md
└── tasks.md             # Phase 2: Generated by /speckit.tasks (not created by this command)
```

### Source Code (repository root)

```text
rtl/
├── peripherals/
│   └── video/
│       ├── dvi_transmitter.v       # DVI/TMDS signal generation (adapted from reference)
│       ├── video_timing.v          # 640x480 @ 60Hz timing generator (hsync, vsync, DE)
│       ├── character_buffer.v      # Dual-port RAM: CPU write port, video read port
│       ├── font_rom.v              # 8x16 font ROM (96 characters: ASCII 0x20-0x7F + placeholder)
│       ├── character_renderer.v    # Scanline-based pixel generation from char buffer + font
│       ├── cursor_controller.v     # Cursor position, flash timing, visibility control
│       ├── color_palette.v         # 3-bit RGB to full RGB conversion (8 colors)
│       ├── gpu_registers.v         # Memory-mapped register interface
│       └── gpu_top.v               # Top-level integration: all submodules + bus interface
│
├── system/
│   └── soc_top.v                   # System integration (connects GPU to CPU bus)
│
└── test/
    └── dvi_test.v                  # Simple test pattern generator for hardware validation

tests/
├── unit/
│   ├── test_video_timing.py        # Cocotb: Verify VGA timing parameters
│   ├── test_character_buffer.py    # Cocotb: Dual-port RAM read/write tests
│   ├── test_font_rom.py            # Cocotb: Font data integrity tests
│   ├── test_character_renderer.py  # Cocotb: Character-to-pixel rendering verification
│   ├── test_cursor_controller.py   # Cocotb: Cursor positioning and flash timing
│   ├── test_color_palette.py       # Cocotb: 3-bit to RGB expansion tests
│   └── test_gpu_registers.py       # Cocotb: Register write/read, control logic
│
├── integration/
│   ├── test_gpu_character_output.py    # End-to-end: Write char, verify pixel output
│   ├── test_gpu_color_modes.py         # Color configuration integration
│   ├── test_gpu_mode_switching.py      # 40/80 column mode switching
│   └── test_gpu_scrolling.py           # Automatic scrolling behavior
│
└── hardware/
    └── test_dvi_output.py          # Hardware-in-the-loop: DVI signal validation on actual board

firmware/
└── gpu/
    ├── gpu_test.s                  # Assembly test program: Write characters, test registers
    └── gpu_demo.s                  # Demo program: Color text, scrolling, cursor movement

docs/
├── modules/
│   ├── dvi_timing.md               # VGA timing specifications, DVI protocol
│   ├── character_rendering.md      # Scanline rendering pipeline explanation
│   └── register_interface.md       # Memory map, register descriptions
├── timing/
│   └── vga_640x480_60hz.md         # Detailed timing diagrams
└── learning/
    ├── how_dvi_works.md            # Educational: DVI/TMDS basics
    └── character_display_basics.md # Educational: Text mode video concepts
```

**Structure Decision**: FPGA/HDL structure as defined in constitution. New `rtl/peripherals/video/` directory for GPU modules. Hardware validation test in `rtl/test/` for initial DVI signal verification using reference code.

## Complexity Tracking

No constitution violations requiring justification.

## Phase 0: Research & Hardware Validation

**Goal**: Validate hardware capabilities and understand DVI signal generation before implementing character display logic.

### Research Tasks

1. **Hardware Validation with Reference Code**
   - Clone and study reference implementation: https://github.com/splinedrive/my_hdmi_device
   - Understand ECP5 LVDS/TMDS primitives used for DVI output
   - Build and test reference code on Colorlight i5 board
   - Verify DVI signal detection on test monitor
   - Document pinout mapping from reference code to Colorlight i5 carrier board
   - Capture known-working synthesis settings (PLL config, timing constraints)

2. **DVI/TMDS Signal Generation**
   - Research DVI protocol vs HDMI (no audio, no HDCP, simpler)
   - Understand TMDS encoding (8b/10b encoding for DC balance)
   - Study ECP5 LVDS primitives: ODDRX2F for DDR output
   - Document pixel clock requirements: 25.175 MHz for 640x480 @ 60Hz
   - Research PLL configuration for generating pixel clock from board oscillator

3. **VGA Timing Standards**
   - Document exact 640x480 @ 60Hz timing parameters:
     - Horizontal: 640 visible, 16 front porch, 96 sync, 48 back porch (total 800)
     - Vertical: 480 visible, 10 front porch, 2 sync, 33 back porch (total 525)
     - Pixel clock: 25.175 MHz
   - Understand hsync, vsync polarity (negative for VGA 640x480)
   - Study blanking intervals and display enable (DE) signal

4. **Character Rendering Architecture**
   - Research text mode rendering approaches:
     - Scanline-based: Fetch character during active video, generate pixels in real-time
     - Tile-based: Pre-render character tiles to frame buffer (too memory intensive)
   - Study 8x16 font format (1 byte per scanline, 16 scanlines per character)
   - Calculate timing budget: 800 pixel clocks per line, need char fetch + font lookup + pixel shift within character time
   - Research dual-port RAM for character buffer (CPU writes, video reads)

5. **ECP5 FPGA Resources**
   - Document available block RAM (EBR) on ECP5-25F
   - Calculate memory requirements:
     - Character buffer: 40x25 = 1000 bytes (1 EBR) or 80x25 = 2000 bytes (2 EBR)
     - Font ROM: 96 characters x 16 bytes = 1536 bytes (1 EBR)
     - Color attributes: Option 1: Per-character color (2 bytes per cell), Option 2: Global color registers (chosen, minimal memory)
   - Research EBR dual-port configuration for concurrent CPU/video access

6. **Memory-Mapped I/O Integration**
   - Study existing RetroCPU memory map (from prior features)
   - Propose GPU register address range (e.g., 0xC000-0xC00F)
   - Research bus interface timing: Synchronize CPU clock domain to pixel clock domain (potential CDC issues)
   - Document register access patterns: Write-only data registers, read/write control registers

### Research Deliverables

**Output File**: `specs/003-hdmi-character-display/research.md`

**Required Content**:
- Hardware validation report: Reference code test results, monitor detection confirmation, pinout mapping
- DVI signal generation: ECP5 primitives, TMDS encoding summary, PLL configuration
- VGA timing specification: Complete timing tables, waveform descriptions
- Character rendering architecture decision: Scanline vs tile-based, chosen approach with rationale
- Memory architecture: EBR allocation strategy, dual-port RAM configuration
- Register interface design: Proposed memory map, CDC strategy for bus interface
- Font format specification: 8x16 bitmap layout, placeholder glyph design
- Open questions for Phase 1 design resolution

**Success Criteria**:
- Reference DVI code successfully synthesizes and runs on Colorlight i5
- Test monitor detects video signal and displays reference pattern/image
- All NEEDS CLARIFICATION items in Technical Context resolved
- Character rendering pipeline timing validated (can fetch char + font data within scanline)

## Phase 1: Design & Contracts

**Goal**: Design module interfaces, register map, and character buffer layout.

### Design Tasks

1. **Module Decomposition**
   - Define module hierarchy from gpu_top down to leaf modules
   - Specify interfaces for each module (ports, parameters, timing requirements)
   - Document module responsibilities and interactions
   - Create block diagrams showing data flow and control signals

2. **Register Interface Specification**
   - Define complete register map with addresses and bit layouts
   - Specify register behaviors (write-only, read-write, read-only status)
   - Document control register bit fields: mode select, cursor enable, clear screen command
   - Define position registers: row (5 bits: 0-24), column (7 bits: 0-79 for 80-col mode)
   - Specify color registers: FG color (3 bits), BG color (3 bits)
   - Document reset values for all registers

3. **Character Buffer Layout**
   - Design buffer organization: Linear array indexed by row*columns + column
   - Specify addressing scheme for 40-column vs 80-column modes
   - Define buffer initialization (all spaces, 0x20, on reset)
   - Document scrolling operation: Memory move algorithm, timing considerations

4. **Font ROM Design**
   - Select or design 8x16 font (consider using standard VGA font)
   - Define placeholder glyph for non-printable characters (0x00-0x1F, 0x7F)
   - Create font data file format (Verilog $readmemh or inline parameter)
   - Document font indexing: Character code to ROM address mapping

5. **Cursor Logic**
   - Design cursor flash timer: Divide pixel clock or frame counter to ~1Hz
   - Specify cursor rendering: XOR or override pixels at cursor position
   - Define cursor visibility control and flash state synchronization
   - Document cursor behavior during scrolling and mode changes

6. **Color Palette**
   - Map 3-bit RGB to full bit depth for DVI output
   - Define 8-color palette values (standard CGA colors)
   - Specify color application: Per-pixel lookup during character rendering
   - Document foreground/background color interaction with cursor rendering

### Design Deliverables

**Output File**: `specs/003-hdmi-character-display/data-model.md`

**Required Content**:
- Module hierarchy diagram with interface specifications
- State machine diagrams (if any, e.g., control register command decoder)
- Timing diagrams for critical operations (character fetch, scrolling)
- Memory layout documentation (character buffer, font ROM addressing)

**Output File**: `specs/003-hdmi-character-display/contracts/register_map.md`

**Required Content**:
- Complete register map table (address, name, access type, reset value)
- Per-register bit field definitions
- Register interaction descriptions (e.g., writing char data auto-increments cursor)
- Example register access sequences (write character, clear screen, change color)

**Output File**: `specs/003-hdmi-character-display/quickstart.md`

**Required Content**:
- Prerequisites: Tool installation (yosys, nextpnr, openFPGALoader)
- Build instructions: Synthesis and programming commands
- Test procedure: Run cocotb tests, program board, verify output
- Troubleshooting guide: Common issues (no video signal, garbled display)

**Agent Context Update**:
Run `.specify/scripts/bash/update-agent-context.sh claude` to add:
- DVI/video hardware specifics (ECP5 LVDS, TMDS encoding)
- Character display architecture patterns
- VGA timing parameters

**Success Criteria**:
- All module interfaces fully specified with port lists
- Register map complete with no ambiguous bit definitions
- Character rendering pipeline timing validated in design
- Quickstart guide enables independent developer to build and test

## Phase 2: Task Breakdown

**Note**: Phase 2 task generation is performed by the `/speckit.tasks` command, NOT by `/speckit.plan`. This section documents the expected scope for task generation.

### Expected Task Categories

1. **Hardware Validation Tasks** (from Phase 0)
   - Clone and build reference DVI code
   - Test reference code on hardware
   - Document pinout and synthesis settings

2. **Core Module Implementation Tasks**
   - Implement DVI transmitter (adapt from reference)
   - Implement video timing generator
   - Implement character buffer (dual-port RAM)
   - Implement font ROM
   - Implement character renderer
   - Implement cursor controller
   - Implement color palette
   - Implement GPU registers
   - Integrate gpu_top module

3. **Testing Tasks** (Test-Driven: Write tests FIRST)
   - Write cocotb test for video timing
   - Write cocotb test for character buffer
   - Write cocotb test for font ROM
   - Write cocotb test for character renderer
   - Write cocotb test for cursor controller
   - Write cocotb test for color palette
   - Write cocotb test for GPU registers
   - Write integration tests (character output, color modes, scrolling)
   - Write firmware test programs

4. **Integration Tasks**
   - Integrate GPU into soc_top
   - Connect GPU to CPU memory bus
   - Test on hardware with firmware
   - Validate all user stories from spec

5. **Documentation Tasks**
   - Document module interfaces
   - Create timing diagrams
   - Write learning materials
   - Update quickstart guide with lessons learned

### Task Generation Approach

Tasks will be ordered following TDD workflow:
1. Hardware validation (prove DVI works)
2. For each module: Write cocotb test → Implement module → Verify test passes
3. Integration testing after all modules complete
4. Hardware validation with full system

## Design Principles

### Test-Driven Development

- **Red-Green-Refactor**: Write failing cocotb test, implement module to pass test, refactor for clarity
- **Test Coverage**: Every module has corresponding cocotb test file
- **Integration Tests**: Character output tests verify end-to-end functionality
- **Hardware Tests**: Final validation on actual Colorlight i5 board with test monitor

### Simplicity Over Performance

- **Scanline Rendering**: Simple sequential character fetch and pixel generation
- **Global Color Registers**: Avoid per-character color attributes to minimize memory
- **Synchronous Design**: Single clock domain where possible, clear CDC for bus interface
- **State Machine Simplicity**: Minimal states, clear transitions, well-documented

### Module Reusability

- **video_timing.v**: Reusable for any VGA resolution (parameterized timing)
- **font_rom.v**: Replaceable font data, reusable font lookup logic
- **character_buffer.v**: Generic dual-port RAM wrapper, reusable for other buffering needs
- **dvi_transmitter.v**: Reusable DVI output for future graphics modes

### Educational Clarity

- **Inline Comments**: Explain VGA timing relationships, TMDS encoding details
- **Learning Docs**: how_dvi_works.md explains video signal basics for learners
- **Timing Diagrams**: Visual representation of scanline rendering pipeline
- **Reference Study**: Document lessons learned from reference implementation

## Next Steps

1. **Run Phase 0 Research** (this command continues)
   - Execute research tasks via parallel Task tool invocations
   - Consolidate findings into research.md
   - Validate hardware with reference code

2. **Run Phase 1 Design** (this command continues)
   - Generate data-model.md with module specifications
   - Create contracts/register_map.md with complete register definitions
   - Write quickstart.md with build instructions
   - Update agent context

3. **User Reviews Plan** (command completes, user action required)
   - Review research findings and design decisions
   - Approve module decomposition and register map
   - Provide feedback or request revisions

4. **Generate Tasks** (next command: `/speckit.tasks`)
   - User runs `/speckit.tasks` to generate tasks.md
   - Tasks decomposed following TDD workflow
   - Tasks prioritized: Hardware validation → Module TDD → Integration → Documentation

---

**Command Status**: Phase 0 Research starting...
