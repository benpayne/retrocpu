# Implementation Plan: 6502 FPGA Microcomputer

**Branch**: `001-6502-fpga-microcomputer` | **Date**: 2025-12-16 | **Spec**: [spec.md](./spec.md)
**Input**: Feature specification from `/specs/001-6502-fpga-microcomputer/spec.md`

## Summary

Build a complete 6502-based microcomputer system on Lattice ECP5 FPGA (Colorlight i5 board) using open-source tools. The system integrates Arlet Ottens' 6502 CPU core with 64KB memory (32KB RAM + 24KB ROM), memory-mapped I/O (UART, HD44780 LCD, PS/2 keyboard), and runs Microsoft 6502 BASIC from ROM. Target architecture prioritizes educational clarity and incremental bring-up over maximum performance, with 1 MHz CPU clock and comprehensive cocotb test coverage per TDD principles.

## Technical Context

**HDL Language**: Verilog (no SystemVerilog, Yosys compatibility requirement)
**Target Architecture**: 6502-compatible retro computer system (NMOS 6502 instruction set)
**CPU Core**: Arlet Ottens' 6502 soft core from GitHub (https://github.com/Arlet/verilog-6502)
**Testing Framework**: cocotb (Python-based HDL verification)
**Simulation**: Icarus Verilog (iverilog) primary, Verilator optional
**Synthesis**: Yosys open-source synthesis
**Place & Route**: nextpnr-ecp5
**Target FPGA**: Lattice ECP5-25F (Colorlight i5 development board)
**Master Clock**: 25 MHz (from P3 pin per colorlight_i5.lpf)
**CPU Clock**: 1 MHz (derived from 25 MHz via clock divider, configurable)
**Project Type**: FPGA/HDL system-on-chip - uses rtl/, tests/, docs/ structure
**Timing Goals**:
  - 1 MHz CPU clock (1 microsecond per cycle)
  - Single-cycle RAM/ROM access
  - Multi-cycle I/O with wait states if needed
**Resource Constraints**:
  - Target: Lattice ECP5-25F (24K LUTs, 1.1 Mbit block RAM)
  - Budget: <19K LUTs (80% utilization target), <30 block RAMs for 64KB memory
  - Reserve 20% headroom per success criteria SC-010
**Module Scope**: Complete system-on-chip including CPU, memory subsystem, address decoder, and three I/O peripherals

**Pin Assignments** (from colorlight_i5.lpf):
- Clock: P3 (25 MHz)
- Reset button: T1 (FIRE 2 button, active-low with pullup)
- UART TX: J17 (to STM32 USB-serial bridge)
- PS/2: K5 (clock), B3 (data) - existing connections
- LCD PMOD: Available PMODs for 7-pin 4-bit interface (to be assigned)
- Status LEDs: N18, N17, L20, M18 (4 LEDs available for debug)
- Additional buttons: U16 (K1), C18 (K2) - available for future use

## Constitution Check

*GATE: Must pass before Phase 0 research. Re-check after Phase 1 design.*

Verify compliance with RetroCPU Constitution (.specify/memory/constitution.md):

- [x] **Test-Driven Design**: Cocotb test framework specified, TDD workflow planned for all modules (tests before implementation)
- [x] **Simplicity Over Performance**: 1 MHz target vs maximum speed, simple single-cycle memory, educational focus over optimization
- [x] **Module Reusability**: Clean module boundaries defined (CPU, memory, address decoder, I/O devices as separate modules)
- [x] **Educational Clarity**: Explicit learning outcomes in success criteria (SC-013 through SC-016), documentation requirements included
- [x] **Open Source Tooling**: Yosys, nextpnr, iverilog, cocotb all open source - no proprietary tools
- [x] **Quality Gates**: Test gate (cocotb), simulation gate (iverilog), synthesis gate (yosys), documentation gate specified
- [x] **Technology Stack**: Verilog, cocotb, yosys/nextpnr toolchain confirmed

**Result**: ✅ All gates PASS - No constitution violations. Design fully compliant with educational FPGA principles.

## Project Structure

### Documentation (this feature)

```text
specs/001-6502-fpga-microcomputer/
├── spec.md              # Feature specification (completed)
├── plan.md              # This file (implementation plan)
├── research.md          # Phase 0: Technology research and decisions
├── data-model.md        # Phase 1: Memory map and register definitions
├── quickstart.md        # Phase 1: Quick start guide for users
├── contracts/           # Phase 1: Module interface definitions
│   ├── cpu_interface.md
│   ├── memory_map.md
│   ├── uart_registers.md
│   ├── lcd_registers.md
│   └── ps2_registers.md
└── tasks.md             # Phase 2: Generated by /speckit.tasks command
```

### Source Code (repository root)

```text
# FPGA/HDL Project Structure
rtl/
├── cpu/
│   └── cpu6502.v        # Arlet Ottens' 6502 core (external dependency)
├── memory/
│   ├── ram.v            # 32KB RAM block (block RAM inference)
│   ├── rom_basic.v      # 16KB BASIC ROM ($8000-$BFFF)
│   ├── rom_monitor.v    # 8KB monitor ROM ($E000-$FFFF)
│   └── address_decoder.v # Memory and I/O address decode logic
├── peripherals/
│   ├── uart/
│   │   ├── uart.v       # Top-level UART module
│   │   ├── uart_tx.v    # Transmit path with baud generator
│   │   └── uart_rx.v    # Receive path (future, not P1)
│   ├── lcd/
│   │   ├── lcd_controller.v      # HD44780 controller top-level
│   │   ├── lcd_init_fsm.v        # Initialization state machine
│   │   └── lcd_timing.v          # Timing generator for HD44780
│   └── ps2/
│       ├── ps2_keyboard.v        # Existing PS/2 interface (integration)
│       └── ps2_debounce.v        # Clock/data debouncing
├── system/
│   ├── clock_divider.v  # 25 MHz → 1 MHz CPU clock generation
│   ├── reset_controller.v # Power-on reset + button debounce/sync
│   └── soc_top.v        # Top-level system integration
└── util/
    └── bram_init.vh     # Block RAM initialization helpers

tests/
├── unit/
│   ├── test_cpu.py              # CPU instruction execution tests
│   ├── test_ram.py              # RAM read/write tests
│   ├── test_address_decoder.py  # Address decode verification
│   ├── test_uart_tx.py          # UART transmit tests
│   ├── test_lcd_controller.py   # LCD controller tests
│   ├── test_ps2_keyboard.py     # PS/2 interface tests
│   ├── test_clock_divider.py    # Clock generation tests
│   └── test_reset.py            # Reset behavior tests
├── integration/
│   ├── test_memory_bus.py       # CPU-memory integration
│   ├── test_io_access.py        # CPU-peripheral access
│   └── test_system_boot.py      # Full system boot sequence
└── fixtures/
    ├── monitor_rom.hex          # Minimal test monitor program
    └── test_program.hex         # Simple 6502 test programs

firmware/
├── monitor/
│   ├── monitor.s        # Monitor program source (6502 assembly)
│   ├── Makefile         # Build monitor.hex
│   └── README.md        # Monitor commands and usage
└── basic/
    ├── msbasic.bin      # Microsoft BASIC binary (external)
    ├── io_vectors.s     # I/O vector patches for UART
    └── Makefile         # Convert to basic_rom.hex

docs/
├── modules/
│   ├── cpu.md           # CPU core integration notes
│   ├── memory.md        # Memory subsystem documentation
│   ├── uart.md          # UART module guide
│   ├── lcd.md           # LCD controller guide
│   └── ps2.md           # PS/2 keyboard guide
├── timing/
│   ├── clock_domains.md # Clock domain analysis
│   ├── bus_timing.md    # CPU bus timing diagrams
│   └── io_timing.md     # I/O device timing requirements
└── learning/
    ├── 6502_basics.md   # 6502 architecture introduction
    ├── memory_map.md    # Address space explanation
    └── hdl_patterns.md  # Common HDL patterns used

build/
├── Makefile             # Top-level build orchestration
└── constraints/
    └── colorlight_i5.lpf # Pin assignments (already exists)

sim/                     # Simulation artifacts (gitignored)
└── waveforms/

synth/                   # Synthesis outputs (gitignored)
└── reports/
```

**Structure Decision**: Using standard FPGA project structure with rtl/ for synthesizable Verilog, tests/ for cocotb verification, firmware/ for 6502 ROM code, and docs/ for educational materials. Structure supports incremental development (CPU → Memory → I/O peripherals) and allows independent module testing per TDD requirements.

## Complexity Tracking

> **Fill ONLY if Constitution Check has violations that must be justified**

No violations detected. All design decisions align with constitution principles.

## Phase 0: Research & Technology Decisions

### Research Tasks

1. **Arlet 6502 Core Integration**
   - Repository: https://github.com/Arlet/verilog-6502
   - Interface signals: clk, reset, AB[15:0], DI[7:0], DO[7:0], WE, IRQ, NMI, RDY
   - Timing: Single-cycle execution with RDY for wait states
   - Synthesis: Verify Yosys compatibility, resource usage estimates

2. **Block RAM Configuration for ECP5**
   - ECP5 block RAM primitives: DP16KD (dual-port 16Kbit blocks)
   - 64KB requires: 32 blocks (512Kbit total, within 1.1Mbit budget)
   - Initialization: $readmemh() for ROM content
   - Inference: Proper Verilog patterns for Yosys block RAM inference

3. **UART Baud Rate Generation**
   - 25 MHz clock → 9600 baud: divider = 25,000,000 / (16 * 9600) ≈ 163
   - Use 16x oversampling for reliable reception
   - Configurable divider for future baud rates (115200, etc.)

4. **HD44780 LCD Timing (4-bit mode)**
   - Initialization sequence: Power-on → wait 15ms → function set → display on
   - Enable pulse: minimum 450ns (12 clocks at 25 MHz)
   - Command delays: 1.64ms (busy wait or status polling)
   - 4-bit mode: send high nibble, then low nibble with E pulses

5. **PS/2 Protocol (using existing module)**
   - Clock: 10-16.7 kHz (bidirectional, device-driven)
   - Data format: 1 start, 8 data, 1 parity, 1 stop bit
   - Scan codes: Set 2 (make/break codes), software decoding required
   - Integration: Existing ps2_keyboard.v provides scan code output

6. **Reset Strategy**
   - Power-on reset: RC delay or counter-based (>10ms stable)
   - Button debounce: Synchronizer + stable counter (50ms debounce)
   - Reset duration: Hold for minimum 2 CPU clock cycles
   - Synchronization: Button synchronized to 25 MHz clock

7. **Clock Domain Strategy**
   - Single 25 MHz clock domain (avoid CDC issues)
   - CPU clock enable (pulse every 25 cycles for 1 MHz)
   - I/O timing: Multi-cycle operations using enable signals
   - No asynchronous clock crossings

8. **Microsoft BASIC ROM**
   - Source: OSI (Ohio Scientific) 6502 BASIC or EhBASIC (MIT license)
   - Size: ~12KB typical, fits in 16KB ROM space
   - I/O vectors: Locations $FFEE-$FFF9 need patching to UART routines
   - Build: Convert .bin to .hex for $readmemh

9. **Monitor Program Requirements**
   - Commands: E (examine), D (deposit), J (jump), G (go to BASIC)
   - Size target: <1KB (leaves 7KB for vectors and utilities)
   - UART I/O: Polling-based character I/O routines
   - Assembler: ca65 (cc65 toolchain) or AS65

10. **Synthesis Constraints**
    - Timing: No strict timing constraints initially (1 MHz is very slow)
    - Area: Monitor LUT usage, aim for <15K LUTs (P1+P2 features)
    - Block RAM: All memory must use block RAM (no distributed RAM)
    - I/O standards: LVCMOS33 for all pins per colorlight_i5.lpf

### Research Output

**Decision Summary**: All technologies and approaches are well-established and feasible. No blocking unknowns identified. Arlet 6502 core is confirmed Yosys-compatible, ECP5 block RAM capacity is sufficient, and all I/O timing requirements are achievable at 25 MHz system clock. Existing PS/2 module can be integrated directly.

## Phase 1: Design Artifacts

### Memory Map (data-model.md)

```
6502 Address Space (64 KB)
===========================

$0000-$00FF : Zero Page RAM (256 bytes)
  - Fast access, used for 6502 zero-page addressing mode
  - Stack pointer addressing, temporary variables

$0100-$01FF : Stack RAM (256 bytes)
  - Hardware stack (6502 SP points here)
  - Grows downward from $01FF

$0200-$7FFF : General Purpose RAM (31.5 KB)
  - BASIC program storage
  - BASIC variables and arrays
  - User program workspace

$8000-$BFFF : BASIC ROM (16 KB)
  - Microsoft 6502 BASIC interpreter
  - Read-only, initialized from basic_rom.hex

$C000-$C0FF : UART Registers (256-byte page)
  - $C000: UART Data Register (R/W)
    - Write: Transmit byte
    - Read: Receive byte (future)
  - $C001: UART Status Register (R)
    - Bit 0: TX ready (1 = can write)
    - Bit 1: RX ready (1 = data available, future)
    - Bit 7: RX overrun (future)
  - $C002: UART Control Register (W, future)
    - Baud rate selection
  - $C003-$C0FF: Reserved for future UART features

$C100-$C1FF : LCD Registers (256-byte page)
  - $C100: LCD Data Register (W)
    - Write: Send character to LCD
  - $C101: LCD Command Register (W)
    - Write: Send HD44780 command
  - $C102: LCD Status Register (R)
    - Bit 0: Busy flag (1 = LCD busy, 0 = ready)
    - Bit 7: Address counter (future)
  - $C103-$C1FF: Reserved for LCD extensions

$C200-$C2FF : PS/2 Keyboard Registers (256-byte page)
  - $C200: PS/2 Data Register (R)
    - Read: Last scan code received
  - $C201: PS/2 Status Register (R)
    - Bit 0: Data ready (1 = new scan code available)
    - Bit 1: Make/break (0 = make, 1 = break code)
    - Bit 7: Error flag (parity error, etc.)
  - $C202-$C2FF: Reserved for keyboard extensions

$C300-$DFFF : Reserved I/O Space (49.75 KB)
  - Future peripherals (timer, sound, etc.)
  - Accesses return $FF, writes ignored

$E000-$FFEF : Monitor ROM (8 KB - 16 bytes)
  - Monitor program
  - Utility routines
  - Character I/O functions

$FFF0-$FFF9 : I/O Vectors (10 bytes)
  - BASIC I/O hooks (output, input, status)
  - Patched to point to UART routines in monitor

$FFFA-$FFFB : NMI Vector
  - Points to NMI handler (simple RTI initially)

$FFFC-$FFFD : RESET Vector
  - Points to monitor start ($E000)

$FFFE-$FFFF : IRQ/BRK Vector
  - Points to IRQ handler (simple RTI initially)
```

### Module Interfaces (contracts/)

See research.md for detailed module interface specifications including all signals, timing requirements, and protocol details for each major module.

### Quick Start Guide (quickstart.md)

```markdown
# 6502 FPGA Microcomputer Quick Start

## Prerequisites

- Colorlight i5 FPGA board
- USB cable for programming and UART
- Serial terminal (minicom, screen, PuTTY)
- Optional: HD44780 2x16 LCD with PMOD adapter
- Optional: PS/2 keyboard

## Tool Installation

```bash
# Install open-source FPGA toolchain
sudo apt install yosys nextpnr-ecp5 ecppack
sudo apt install iverilog gtkwave  # Simulation
pip3 install cocotb cocotb-test    # Testing framework

# Install 6502 assembler for monitor/firmware
sudo apt install cc65  # Provides ca65 assembler
```

## Build & Program

```bash
# Clone project
git clone <repo-url>
cd retrocpu

# Fetch 6502 core dependency
git submodule update --init

# Build firmware (monitor + BASIC ROM)
cd firmware/monitor
make  # Generates monitor.hex
cd ../basic
make  # Generates basic_rom.hex

# Run tests (TDD verification)
cd ../../tests
make test-unit         # Unit tests
make test-integration  # Integration tests

# Synthesize FPGA bitstream
cd ../build
make synth             # Yosys synthesis
make pnr               # nextpnr place-and-route
make bitstream         # Generate .bit file

# Program FPGA
make program           # Uses openFPGALoader
```

## First Boot

1. **Connect Hardware**
   - USB cable to Colorlight i5
   - Serial terminal: 9600 baud, 8N1

2. **Program FPGA**
   ```bash
   make program
   ```

3. **Open Serial Terminal**
   ```bash
   screen /dev/ttyUSB0 9600
   ```

4. **Expected Output**
   ```
   RetroCPU Monitor v1.0

   Commands:
     E addr      Examine memory
     D addr val  Deposit byte
     J addr      Jump to address
     G           Go to BASIC

   >
   ```

5. **Run BASIC**
   ```
   > G
   Microsoft BASIC
   Ready
   >PRINT 2+2
   4
   >
   ```

## Troubleshooting

- **No output**: Check UART connection, baud rate (9600), reset button
- **Garbled text**: Verify baud rate, check clock frequency
- **System hangs**: Press reset button (FIRE 2 / T1 pin)
- **Synthesis fails**: Check Yosys/nextpnr versions, verify .lpf file

## Next Steps

- Connect LCD display (PMOD connector)
- Connect PS/2 keyboard
- Modify memory map for custom I/O
- Write 6502 assembly programs
- Explore BASIC programs

## Learning Resources

- docs/learning/6502_basics.md - CPU architecture
- docs/learning/memory_map.md - Address space guide
- docs/modules/ - Module documentation
```

## Phase 2: Tasks Generation

Tasks will be generated by the `/speckit.tasks` command after this plan is complete. Task generation will follow the user story priorities (P1 → P2 → P3 → P4 → P5) with proper dependency ordering and TDD workflow (tests before implementation).

Expected task phases:
1. **Setup**: Project initialization, tool verification
2. **Foundational**: Clock/reset, basic infrastructure
3. **P1 (Monitor)**: CPU + Memory + UART + Monitor boot
4. **P2 (BASIC)**: BASIC ROM integration and execution
5. **P3 (LCD)**: HD44780 LCD controller
6. **P4 (Keyboard)**: PS/2 keyboard integration
7. **P5 (Standalone)**: Combined LCD + keyboard operation
8. **Polish**: Documentation, optimization, educational materials

## Notes

- Pinout file (colorlight_i5.lpf) already exists with correct pin assignments
- PS/2 keyboard module already implemented (ps2_keyboard.v) - integration task
- Reset button mapped to T1 (FIRE 2 button) with active-low, pull-up
- UART TX only for P1/P2 (RX reception future enhancement)
- All timing is conservative (1 MHz CPU, 25 MHz system) - no timing closure issues expected
- TDD workflow: Every module has cocotb tests written BEFORE implementation
- Educational focus maintained throughout - clarity over performance
